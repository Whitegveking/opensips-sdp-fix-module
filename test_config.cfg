#
# OpenSIPS SDP Fix Module 测试配置文件
# 用于验证SDP负载类型不匹配修复功能
#

####### Global Parameters #########
log_level=4
xlog_level=4
stderror_enabled=yes
syslog_enabled=yes
syslog_facility=LOG_LOCAL0
log_name="opensips-sdp-fix"
auto_aliases=no

# 启用详细的SIP消息日志
debug_mode=yes

# 设置监听地址和端口 - 作为代理服务器
socket=udp:192.168.143.128:5060

# 设置模块路径
mpath="/usr/local/lib64/opensips/modules/"

####### Modules Section ########

#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

#### Record Route Module
loadmodule "rr.so"
modparam("rr", "append_fromtag", 0)

#### MAX_FORWARDS
loadmodule "maxfwd.so"

#### UDP protocol
loadmodule "proto_udp.so"

#### SIP MESSAGE OPS module
loadmodule "sipmsgops.so"

#### Dialog module - 用于会话状态跟踪
loadmodule "dialog.so"
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "default_timeout", 21600)

#### 加载我们的SDP修复模块
loadmodule "sdp_fix.so"

####### Routing Logic ########

# 主路由块
route {
    xlog("L_INFO", "SDP_FIX_TEST: [$rm] 请求从 $si:$sp 到 $ru\n");
    
    # 基本检查
    if (!mf_process_maxfwd_header(10)) {
        xlog("L_WARN", "SDP_FIX_TEST: Too many hops detected\n");
        send_reply(483, "Too Many Hops");
        exit;
    }

    # 处理已有tag的请求(后续请求)
    if (has_totag()) {
        xlog("L_INFO", "SDP_FIX_TEST: 处理后续请求 [$rm]\n");
        
        # 检查是否是重传的INVITE
        if (is_method("INVITE") && t_check_trans()) {
            xlog("L_INFO", "SDP_FIX_TEST: INVITE重传，转发\n");
            t_relay();
            exit;
        }
        
        # 处理序列内请求
        if (loose_route()) {
            xlog("L_INFO", "SDP_FIX_TEST: 路由序列内请求\n");
            
            # 对于UPDATE请求，存储编解码器信息
            if (is_method("UPDATE")) {
                xlog("L_INFO", "SDP_FIX_TEST: 处理UPDATE请求，存储编解码器信息\n");
                if (has_body("application/sdp")) {
                    xlog("L_INFO", "SDP_FIX_TEST: UPDATE包含SDP内容\n");
                    # 调用模块函数存储UPDATE中的编解码器
                    if (store_update_codecs()) {
                        xlog("L_INFO", "SDP_FIX_TEST: 成功存储UPDATE编解码器信息\n");
                    } else {
                        xlog("L_WARN", "SDP_FIX_TEST: 存储UPDATE编解码器失败\n");
                    }
                }
            }
            
            if (is_method("INVITE")) {
                record_route();
            }
            
            # 设置回复路由来处理200 OK响应
            t_on_reply("handle_replies");
            t_relay();
            exit;
        } else {
            if (is_method("ACK")) {
                xlog("L_INFO", "SDP_FIX_TEST: ACK for non-existing transaction\n");
                exit;
            }
            xlog("L_WARN", "SDP_FIX_TEST: 请求不在对话内\n");
            send_reply(404, "Not here");
            exit;
        }
    }

    # 处理初始请求
    xlog("L_INFO", "SDP_FIX_TEST: 处理初始请求 [$rm]\n");
    
    # 对于初始INVITE，创建对话
    if (is_method("INVITE")) {
        xlog("L_INFO", "SDP_FIX_TEST: 处理初始INVITE请求\n");
        create_dialog();
        record_route();
    }
    
    # 对于UPDATE请求，存储编解码器信息
    if (is_method("UPDATE")) {
        xlog("L_INFO", "SDP_FIX_TEST: 处理UPDATE请求\n");
        if (has_body("application/sdp")) {
            xlog("L_INFO", "SDP_FIX_TEST: UPDATE包含SDP，存储编解码器信息\n");
            # 调用模块函数
            if (store_update_codecs()) {
                xlog("L_INFO", "SDP_FIX_TEST: 成功存储UPDATE编解码器信息\n");
            } else {
                xlog("L_WARN", "SDP_FIX_TEST: 存储UPDATE编解码器失败\n");
            }
        }
    }
    
    # 设置回复路由
    t_on_reply("handle_replies");
    
    # 转发请求
    if (!t_relay()) {
        xlog("L_ERR", "SDP_FIX_TEST: 转发失败\n");
        send_reply(500, "Internal Server Error");
    }
}

# 处理回复的路由
onreply_route[handle_replies] {
    xlog("L_INFO", "SDP_FIX_TEST: 收到回复 [$rs $rr] for [$rm]\n");
    
    # 处理UPDATE的200 OK回复
    if (is_method("UPDATE") && $rs == 200) {
        xlog("L_INFO", "SDP_FIX_TEST: 处理UPDATE的200 OK回复\n");
        
        if (has_body("application/sdp")) {
            xlog("L_INFO", "SDP_FIX_TEST: 200 OK包含SDP，检查编解码器兼容性\n");
            
            # 检查编解码器兼容性
            $var(compat_result) = check_codec_compatibility();
            xlog("L_INFO", "SDP_FIX_TEST: 兼容性检查结果: $var(compat_result)\n");
            
            if ($var(compat_result) == -1) {
                xlog("L_WARN", "SDP_FIX_TEST: 检测到编解码器不匹配，尝试修复\n");
                
                # 尝试修复编解码器不匹配
                if (fix_codec_mismatch()) {
                    xlog("L_INFO", "SDP_FIX_TEST: 成功修复编解码器不匹配问题\n");
                } else {
                    xlog("L_ERR", "SDP_FIX_TEST: 修复编解码器不匹配失败\n");
                }
            } else if ($var(compat_result) == 1) {
                xlog("L_INFO", "SDP_FIX_TEST: 编解码器兼容，无需修复\n");
            } else {
                xlog("L_ERR", "SDP_FIX_TEST: 编解码器不兼容，无法修复\n");
            }
        }
    }
    
    # 对于其他回复，只是记录
    if ($rs >= 200 && $rs < 300) {
        xlog("L_INFO", "SDP_FIX_TEST: 成功回复 [$rs]\n");
    } else if ($rs >= 300) {
        xlog("L_INFO", "SDP_FIX_TEST: 错误/重定向回复 [$rs]\n");
    }
}

# 失败路由
failure_route[1] {
    xlog("L_ERR", "SDP_FIX_TEST: 请求失败 - $T_reply_code\n");
    
    if (t_was_cancelled()) {
        xlog("L_INFO", "SDP_FIX_TEST: 请求被取消\n");
        exit;
    }
}

# 错误路由
error_route {
    xlog("L_ERR", "SDP_FIX_TEST: 路由错误: $(err.level) / $(err.info)\n");
}

# 本地路由 - 处理本地生成的请求
local_route {
    xlog("L_INFO", "SDP_FIX_TEST: 本地路由 [$rm] to $ru\n");
}
