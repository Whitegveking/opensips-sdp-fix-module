#
# OpenSIPS测试配置文件 - 带SDP修复模块
#

####### Global Parameters #########
log_level=3
xlog_level=3
stderror_enabled=no
syslog_enabled=yes

# 设置监听地址和端口
socket=udp:192.168.143.128:5060 

# 设置模块路径
mpath="/usr/local/lib64/opensips/modules/"

####### Modules Section ########

#### 基础传输协议模块
loadmodule "proto_udp.so"

#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)

#### Record Route Module
loadmodule "rr.so"

#### MAX_FORWARDS
loadmodule "maxfwd.so"

#### SIP MESSAGE OPS module
loadmodule "sipmsgops.so"

#### Text operations module
loadmodule "textops.so"

#### SDP Fix Module - 我们的自定义模块
loadmodule "sdp_fix.so"

####### Routing Logic ########

# 主路由块
route {
    # 检查最大转发数
    if (!mf_process_maxfwd_header(10)) {
        send_reply(483, "Too Many Hops");
        exit;
    }

    # 记录所有收到的消息
    xlog("L_INFO", "Received $rm from $fU to $tU via $si:$sp\n");

    # 处理重传和后续请求
    if (has_totag()) {
        # 处理ACK
        if (is_method("ACK") && t_check_trans()) {
            xlog("L_INFO", "Processing ACK\n");
            t_relay();
            exit;
        }
        
        # 处理路由头
        if (loose_route()) {
            xlog("L_INFO", "Loose routing to $du\n");
            if (is_method("INVITE")) {
                record_route();
            }
            route(relay);
            exit;
        } else {
            xlog("L_INFO", "No loose route found\n");
            # 不要直接返回404，而是尝试转发到UAS
            route(to_uas);
            exit;
        }
    }

    # 处理CANCEL
    if (is_method("CANCEL")) {
        if (t_check_trans())
            t_relay();
        exit;
    }

    # 检查重传
    t_check_trans();

    # 记录路由
    if (!is_method("REGISTER|MESSAGE"))
        record_route();

    # 转发到UAS
    route(to_uas);
}

# 转发到UAS的路由
route[to_uas] {
    # 设置目标为UAS (端口5070)
    $du = "sip:192.168.143.128:5070";
    
    xlog("L_INFO", "Forwarding $rm to UAS at $du\n");
    
    # 检查SDP负载并调用模块尝试修复不匹配的 rtpmap/fmtp
    if (has_body("application/sdp")) {
        xlog("L_INFO", "$rm has SDP body, attempting SDP fix via sdp_fix module...\n");

        # 调用模块导出函数 fix_sdp_rtpmap()（直接调用，结果由模块日志记录）
        fix_sdp_rtpmap();
        xlog("L_INFO", "SDP fix attempted via sdp_fix module (see module logs for details)\n");
    }
    
    route(relay);
}

# 转发路由
route[relay] {
    # 为INVITE启用额外的处理路由
    if (is_method("INVITE")) {
        t_on_reply("handle_replies");
        t_on_failure("handle_failure");
    }
    
    # 为UPDATE消息也启用回复处理
    if (is_method("UPDATE")) {
        t_on_reply("handle_replies");
        t_on_failure("handle_failure");
    }

    if (!t_relay()) {
        xlog("L_ERR", "Relay failed\n");
        send_reply(500, "Internal Error");
    }
    exit;
}

# 处理回复
onreply_route[handle_replies] {
    xlog("L_INFO", "Received reply: $rs $rr\n");
    
    # 检查回复中的SDP并尝试修复
    if (has_body("application/sdp")) {
        xlog("L_INFO", "Reply has SDP body, attempting SDP fix via sdp_fix module...\n");

    # 直接调用修复函数并记录（模块会输出修复/错误日志）
    fix_sdp_rtpmap();
    xlog("L_INFO", "Reply SDP fix attempted via sdp_fix module (see module logs for details)\n");
    }
}

# 处理失败
failure_route[handle_failure] {
    xlog("L_INFO", "Call failed with status $T_reply_code\n");
    
    if (t_was_cancelled()) {
        xlog("L_INFO", "Call was cancelled\n");
        exit;
    }
    
    # 如果是由于SDP验证失败导致的错误，记录详细信息
    if ($T_reply_code == 488) {
        xlog("L_ERR", "Call failed due to SDP incompatibility (488 Not Acceptable Here)\n");
        
        # 如果原始请求是INVITE，事务会被自动取消
        if (is_method("INVITE")) {
            xlog("L_INFO", "INVITE failed due to SDP validation\n");
        }
    }
    
    # 其他失败处理逻辑
    xlog("L_INFO", "Transaction failed: method=$rm, code=$T_reply_code\n");
}
